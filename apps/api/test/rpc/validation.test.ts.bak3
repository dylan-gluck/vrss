/**
 * RPC Validation Middleware Tests
 * Test that Zod schemas validate input correctly for all procedures
 *
 * Following TDD: These tests are written BEFORE implementation
 */

import { beforeEach, describe, expect, it } from "bun:test";
import { Hono } from "hono";
import { createRPCRouter } from "../../src/rpc/index";
import { cleanAllTables } from "../helpers/database";

describe("RPC Validation Middleware", () => {
  let app: Hono;

  beforeEach(async () => {
    await cleanAllTables();
    app = new Hono();
    app.route("/", createRPCRouter());
  });

  describe("Input Validation", () => {
    it("should reject invalid email format", async () => {
      const response = await app.fetch(new Request("http://localhost/", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          procedure: "auth.register",
          input: {
            username: "testuser",
            email: "not-an-email", // Invalid email
            password: "password123",
          },
        }),
      });

      const data = await response.json();
      expect(data.success).toBe(false);
      expect(data.error.code).toBe(1200); // VALIDATION_ERROR
      expect(data.error.message).toContain("email");
    });

    it("should reject password shorter than 8 characters", async () => {
      const response = await app.fetch(new Request("http://localhost/", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          procedure: "auth.register",
          input: {
            username: "testuser",
            email: "test@example.com",
            password: "short", // Too short
          },
        }),
      });

      const data = await response.json();
      expect(data.success).toBe(false);
      expect(data.error.code).toBe(1200); // VALIDATION_ERROR
      expect(data.error.message).toContain("password");
    });

    it("should reject missing required fields", async () => {
      const response = await app.fetch(new Request("http://localhost/", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          procedure: "auth.register",
          input: {
            username: "testuser",
            // Missing email and password
          },
        }),
      });

      const data = await response.json();
      expect(data.success).toBe(false);
      expect(data.error.code).toBe(1200); // VALIDATION_ERROR
      expect(data.error.details).toBeDefined();
    });

    it("should provide detailed validation error messages", async () => {
      const response = await app.fetch(new Request("http://localhost/", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          procedure: "auth.register",
          input: {
            username: "", // Empty
            email: "invalid-email",
            password: "123", // Too short
          },
        }),
      });

      const data = await response.json();
      expect(data.success).toBe(false);
      expect(data.error.code).toBe(1200);
      expect(data.error.details).toBeDefined();

      // Should have details about multiple validation failures
      const details = data.error.details as any;
      expect(details).toHaveProperty("fieldErrors");
    });
  });

  describe("Type-Specific Validation", () => {
    it("should validate post content length", async () => {
      const longContent = "a".repeat(10000); // Exceeds max length

      const response = await app.fetch(new Request("http://localhost/", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          Authorization: "Bearer test-token", // Would need valid session
        },
        body: JSON.stringify({
          procedure: "post.create",
          input: {
            type: "text",
            content: longContent,
            visibility: "public",
          },
        }),
      });

      const data = await response.json();
      // Might be auth error or validation error depending on implementation order
      if (data.error.code >= 1200 && data.error.code < 1300) {
        expect(data.error.message).toContain("content");
      }
    });

    it("should validate enum values", async () => {
      const response = await app.fetch(new Request("http://localhost/", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          Authorization: "Bearer test-token",
        },
        body: JSON.stringify({
          procedure: "post.create",
          input: {
            type: "invalid-type", // Not a valid PostType
            content: "Test content",
            visibility: "public",
          },
        }),
      });

      const data = await response.json();
      if (data.error.code >= 1200 && data.error.code < 1300) {
        expect(data.error.message).toContain("type");
      }
    });

    it("should validate array length limits", async () => {
      const tooManyTags = new Array(20).fill("tag"); // Exceeds max tags

      const response = await app.fetch(new Request("http://localhost/", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          Authorization: "Bearer test-token",
        },
        body: JSON.stringify({
          procedure: "post.create",
          input: {
            type: "text",
            content: "Test content",
            visibility: "public",
            tags: tooManyTags,
          },
        }),
      });

      const data = await response.json();
      if (data.error.code >= 1200 && data.error.code < 1300) {
        expect(data.error.message).toContain("tag");
      }
    });
  });

  describe("Schema Transformation", () => {
    it("should apply default values", async () => {
      // When visibility is not provided, should default to 'public'
      // This will be tested once we have a working procedure with auth
      const expectedBehavior = {
        defaultVisibility: "public",
        defaultLimit: 20,
        defaultCursor: undefined,
      };

      expect(expectedBehavior).toBeDefined();
    });

    it("should coerce types when appropriate", async () => {
      // Zod can coerce strings to numbers, etc.
      // This documents expected behavior
      const expectedCoercion = {
        stringToNumber: true,
        dateString: true,
      };

      expect(expectedCoercion).toBeDefined();
    });
  });

  describe("Nested Object Validation", () => {
    it("should validate nested profile style objects", async () => {
      const response = await app.fetch(new Request("http://localhost/", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          Authorization: "Bearer test-token",
        },
        body: JSON.stringify({
          procedure: "user.updateStyle",
          input: {
            backgroundColor: "not-a-color", // Invalid color format
            primaryColor: "#invalid",
          },
        }),
      });

      const data = await response.json();
      if (data.error.code >= 1200 && data.error.code < 1300) {
        expect(data.error.details).toBeDefined();
      }
    });

    it("should validate feed filter structures", async () => {
      const response = await app.fetch(new Request("http://localhost/", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          Authorization: "Bearer test-token",
        },
        body: JSON.stringify({
          procedure: "feed.createFeed",
          input: {
            name: "My Feed",
            filters: [
              {
                type: "invalid-filter-type", // Invalid
                operator: "include",
                value: [],
              },
            ],
          },
        }),
      });

      const data = await response.json();
      if (data.error.code >= 1200 && data.error.code < 1300) {
        expect(data.error.message).toContain("filter");
      }
    });
  });

  describe("Optional vs Required Fields", () => {
    it("should allow optional fields to be omitted", async () => {
      // bio, avatarUrl, etc. are optional
      const response = await app.fetch(new Request("http://localhost/", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          Authorization: "Bearer test-token",
        },
        body: JSON.stringify({
          procedure: "user.updateProfile",
          input: {
            displayName: "New Name",
            // bio and avatarUrl omitted (optional)
          },
        }),
      });

      // Should not fail validation for missing optional fields
      const data = await response.json();
      if (!data.success && data.error.code >= 1200 && data.error.code < 1300) {
        // If it's a validation error, it shouldn't be about optional fields
        expect(data.error.message).not.toContain("bio");
        expect(data.error.message).not.toContain("avatar");
      }
    });

    it("should reject when required fields are missing", async () => {
      const response = await app.fetch(new Request("http://localhost/", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          procedure: "auth.login",
          input: {
            email: "test@example.com",
            // password missing (required)
          },
        }),
      });

      const data = await response.json();
      expect(data.success).toBe(false);
      expect(data.error.code).toBe(1200); // VALIDATION_ERROR
      expect(data.error.message).toContain("password");
    });
  });

  describe("Custom Validators", () => {
    it("should validate username format (alphanumeric, 3-20 chars)", async () => {
      const invalidUsernames = [
        "ab", // Too short
        "a".repeat(21), // Too long
        "user@name", // Invalid characters
        "user name", // Space
      ];

      for (const username of invalidUsernames) {
        const response = await app.fetch(new Request("http://localhost/", {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
          },
          body: JSON.stringify({
            procedure: "auth.register",
            input: {
              username,
              email: "test@example.com",
              password: "password123",
            },
          }),
        });

        const data = await response.json();
        expect(data.success).toBe(false);
      }
    });

    it("should validate file size limits", async () => {
      const response = await app.fetch(new Request("http://localhost/", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          Authorization: "Bearer test-token",
        },
        body: JSON.stringify({
          procedure: "media.initiateUpload",
          input: {
            filename: "large-file.mp4",
            contentType: "video/mp4",
            size: 1024 * 1024 * 1024 * 10, // 10GB - exceeds limits
          },
        }),
      });

      const data = await response.json();
      if (!data.success) {
        // Should be either validation error or storage quota error
        expect([1200, 1600]).toContain(Math.floor(data.error.code / 100) * 100);
      }
    });
  });
});
